

# Software Design

<details>

<summary>Software Architecture</summary>

- The high-level structure of a software system.

- Defines components, relationships, and system behavior.

- Guides the development and ensures scalability.

</details>

<details>

<summary>Design Patterns</summary>

- Proven solutions to common design problems.

- Reusable templates for solving recurring software design issues.

- Promotes code reusability and maintainability.

</details>

<details>

<summary>Object-Oriented Design</summary>

- Organizing code around objects and their interactions.

- Encapsulation, inheritance, and polymorphism principles.

- Enhances code modularity and understanding.

</details>

<details>

<summary>Modular Design</summary>

- Breaking software into smaller, self-contained modules.

- Each module has a specific function and interfaces with others.

- Simplifies development, testing, and maintenance.

</details>

<details>

<summary>Component-Based Architecture</summary>

- Building software using reusable components.

- Components encapsulate functionality and can be replaced or extended.

- Promotes code reusability and flexibility.

</details>

<details>

<summary>Layered Architecture</summary>

- Dividing software into logical layers.

- Each layer handles specific tasks or responsibilities.

- Enhances separation of concerns and maintainability.

</details>

<details>

<summary>Service-Oriented Architecture (SOA)</summary>

- Designing software as a set of interconnected services.

- Services are self-contained and communicate through APIs.

- Facilitates scalability and reusability.

</details>

<details>

<summary>Model-View-Controller (MVC)</summary>

- A design pattern for separating concerns in user interfaces.

- Model stores data, View displays it, Controller handles user input.

- Improves code organization and maintainability.

</details>

<details>

<summary>Single Responsibility Principle (SRP)</summary>

- A class should have only one reason to change.

- Each class should have a single, well-defined responsibility.

- Enhances code clarity and maintainability.

</details>

<details>

<summary>Open-Closed Principle (OCP)</summary>

- Software entities should be open for extension but closed for modification.

- Extend behavior without changing existing code.

- Promotes code stability and scalability.

</details>

<details>

<summary>Liskov Substitution Principle (LSP)</summary>

- Subtypes must be substitutable for their base types.

- Derived classes should adhere to the interface of the base class.

- Ensures consistent behavior in polymorphism.

</details>

<details>

<summary>Dependency Inversion Principle (DIP)</summary>

- High-level modules should not depend on low-level modules.

- Both should depend on abstractions, not concretions.

- Facilitates flexibility and testing.

</details>

<details>

<summary>Interface Segregation Principle (ISP)</summary>

- No client should be forced to depend on methods it does not use.

- Divide large interfaces into smaller, specific ones.

- Prevents unnecessary dependencies.

</details>

<details>

<summary>Design by Contract (DbC)</summary>

- A software design approach using formal specifications.

- Defines preconditions, postconditions, and invariants for functions.

- Enhances software correctness and reliability.

</details>

<details>

<summary>Cohesion and Coupling</summary>

- Cohesion measures how closely related code is within a module.

- Coupling measures how dependent one module is on another.

- High cohesion and low coupling improve design.

</details>

<details>

<summary>Abstraction</summary>

- Hiding complex implementation details.

- Focusing on what an object does, not how it does it.

- Enhances code understanding and reduces complexity.

</details>

<details>

<summary>Inheritance vs. Composition</summary>

- Choosing between inheriting from a class or composing with objects.

- Composition often promotes better flexibility and reusability.

- Avoid deep inheritance hierarchies.

</details>

<details>

<summary>Polymorphism</summary>

- The ability to use different classes through a common interface.

- Allows objects of different classes to be treated uniformly.

- Enables dynamic behavior and extensibility.

</details>

<details>

<summary>Design Review</summary>

- A formal evaluation of software design by a team.

- Identifies design flaws, inconsistencies, and potential improvements.

- Ensures design aligns with requirements.

</details>

<details>

<summary>Design Patterns Catalog</summary>

- A collection of documented design patterns.

- Helps designers select appropriate patterns for specific problems.

- Encourages best practices in design.

</details>

<details>

<summary>Architectural Styles</summary>

- Patterns for organizing large-scale systems.

- Examples include client-server, microservices, and event-driven.

- Guides system structure and communication.

</details>

<details>

<summary>State Machines</summary>

- Modeling object behavior through defined states.

- Transitions between states based on events or conditions.

- Useful for modeling complex workflows.

</details>

<details>

<summary>Design Trade-offs</summary>

- Balancing competing factors in design decisions.

- Examples include performance vs. maintainability or flexibility vs. security.

- Critical for making informed design choices.

</details>

<details>

<summary>Code Reusability</summary>

- Writing code that can be used in multiple contexts.

- Promotes efficiency and consistency in software development.

- Requires careful design and abstraction.

</details>

<details>

<summary>User-Centered Design (UCD)</summary>

- Designing software with the end user in mind.

- Involves user research, usability testing, and iterative design.

- Ensures a positive user experience.

</details>

<details>

<summary>Design Documentation</summary>

- Recording and communicating design decisions.

- Includes diagrams, architecture documents, and design patterns.

- Aids in design understanding and collaboration.

</details>

<details>

<summary>Design Validation</summary>

- Testing the design against requirements.

- Ensures that the design meets functional and non-functional specifications.

- Identifies design flaws early in development.

</details>

<details>

<summary>Design Evolution</summary>

- The process of refining and adapting a software design.

- Responds to changing requirements and new insights.

- Ensures a design remains relevant over time.

</details>
